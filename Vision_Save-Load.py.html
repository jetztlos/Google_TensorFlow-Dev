<html>
<head>
<title>Vision_Save-Load.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Vision_Save-Load.py</font>
</center></td></tr></table>
<pre><span class="s0"># From: https://www.tensorflow.org/tutorials/keras/save_and_load</span>
<span class="s0">## Setup</span>
<span class="s0">### Installs and imports</span>
<span class="s0"># ! pip install pyyaml h5py # Required to save models in HDF5 format</span>

<span class="s2">import </span><span class="s1">os</span>

<span class="s2">import </span><span class="s1">tensorflow </span><span class="s2">as </span><span class="s1">tf</span>
<span class="s2">from </span><span class="s1">tensorflow </span><span class="s2">import </span><span class="s1">keras</span>

<span class="s1">print(tf.version.VERSION)</span>

<span class="s0">### Get an ex. dataset</span>
<span class="s1">(train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()</span>

<span class="s1">train_labels = train_labels[:</span><span class="s3">1_000</span><span class="s1">]</span>
<span class="s1">test_labels = test_labels[:</span><span class="s3">1_000</span><span class="s1">]</span>

<span class="s1">train_images = train_images[:</span><span class="s3">1_000</span><span class="s1">].reshape(-</span><span class="s3">1</span><span class="s1">, </span><span class="s3">28 </span><span class="s1">* </span><span class="s3">28</span><span class="s1">) / </span><span class="s3">255.</span>
<span class="s1">test_images = test_images[:</span><span class="s3">1_000</span><span class="s1">].reshape(-</span><span class="s3">1</span><span class="s1">, </span><span class="s3">28 </span><span class="s1">* </span><span class="s3">28</span><span class="s1">) / </span><span class="s3">255.</span>

<span class="s0">### Define a model</span>
<span class="s0"># Define a simple sequential model</span>
<span class="s2">def </span><span class="s1">create_model():</span>
    <span class="s1">model = tf.keras.Sequential([</span>
        <span class="s1">keras.layers.Dense(</span><span class="s3">512</span><span class="s1">, activation=</span><span class="s4">'relu'</span><span class="s1">, input_shape=(</span><span class="s3">784</span><span class="s1">,)),</span>
        <span class="s1">keras.layers.Dropout(</span><span class="s3">0.2</span><span class="s1">),</span>
        <span class="s1">keras.layers.Dense(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">])</span>

    <span class="s1">model.compile(loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=</span><span class="s2">True</span><span class="s1">),</span>
                  <span class="s1">optimizer=</span><span class="s4">'adam'</span><span class="s1">,</span>
                  <span class="s1">metrics=[tf.keras.metrics.SparseCategoricalAccuracy()])</span>

    <span class="s2">return </span><span class="s1">model</span>

<span class="s0"># Create a basic model instance</span>
<span class="s1">model = create_model()</span>

<span class="s0"># Display the model's architecture</span>
<span class="s1">model.summary()</span>

<span class="s0">## Save checkpoints during training</span>
<span class="s0">### Checkpoint callback usage</span>
<span class="s1">checkpoint_path = </span><span class="s4">&quot;training_1/cp.ckpt&quot;</span>
<span class="s1">checkpoint_dir = os.path.dirname(checkpoint_path)</span>

<span class="s0"># Create a callback that saves the model's weights</span>
<span class="s1">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,</span>
                                                 <span class="s1">save_weights_only=</span><span class="s2">True</span><span class="s1">,</span>
                                                 <span class="s1">verbose=</span><span class="s3">1</span><span class="s1">)</span>

<span class="s0"># Train the model w/ the new callback</span>
<span class="s1">model.fit(train_images, train_labels,</span>
          <span class="s1">epochs=</span><span class="s3">10</span><span class="s1">,</span>
          <span class="s1">validation_data=(test_images, test_labels),</span>
          <span class="s1">callbacks=[cp_callback]) </span><span class="s0"># Pass callback to training</span>
    <span class="s0"># This may generate warnings related to saving the state of the optimizer.</span>
    <span class="s0"># (...) are in place to discourage outdated usage, and can be ignored.</span>

<span class="s1">os.listdir(checkpoint_dir)</span>

<span class="s0"># As long as 2 models share the same architecture, you can share the weights bw. them. So, when restoring a model</span>
<span class="s0"># from weights-only, 1) create a model w/ the same architecture as the original model, and</span>
<span class="s0"># 2) set its weights.</span>

<span class="s0"># 1) Now rebuild a fresh, untrained model and evaluate it on the test set. (...) will perform at chance levels (~10% acc):</span>

<span class="s0"># Create a basic model instance</span>
<span class="s1">model = create_model()</span>

<span class="s0"># Evaluate the model</span>
<span class="s1">loss, acc = model.evaluate(test_images, test_labels,</span>
                           <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">&quot;Untrained model, accuracy: {:5.2f}%&quot;</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s0"># 2) Then load the weights from the checkpoint and re-evaluate:</span>

<span class="s0"># Load the weights</span>
<span class="s1">model.load_weights(checkpoint_path)</span>

<span class="s0"># Re-evaluate the model</span>
<span class="s1">loss, acc = model.evaluate(test_images, test_labels,</span>
                           <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">&quot;Restored model, accuracy: {:5.2f}%&quot;</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s0">### Checkpoint callback options</span>
<span class="s0"># Include the epoch in the file name (uses `str.format`)</span>
<span class="s1">checkpoint_path = </span><span class="s4">&quot;training_2/cp-{epoch:04d}.ckpt&quot;</span>
<span class="s1">checkpoint_dir = os.path.dirname(checkpoint_path)</span>

<span class="s1">batch_size = </span><span class="s3">32</span>

<span class="s0"># Calculate the number of batches per epoch</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s1">n_batches = len(train_images) / batch_size</span>
<span class="s1">n_batches = math.ceil(n_batches) </span><span class="s0"># round up the number of batches to the nearest whole integer</span>

<span class="s0"># Create a callback that saves the model's weights every 5 epochs</span>
<span class="s1">cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_path,</span>
                                                 <span class="s1">save_weights_only=</span><span class="s2">True</span><span class="s1">,</span>
                                                 <span class="s1">save_freq = </span><span class="s3">5 </span><span class="s1">* n_batches,</span>
                                                 <span class="s1">verbose=</span><span class="s3">1</span><span class="s1">)</span>

<span class="s0"># Create a new model instance</span>
<span class="s1">model = create_model()</span>

<span class="s0"># Save the weights using the `checkpoint_path` format</span>
<span class="s1">model.save_weights(checkpoint_path.format(epoch=</span><span class="s3">0</span><span class="s1">))</span>

<span class="s0"># Train the model w/ the new callback</span>
<span class="s1">model.fit(train_images, train_labels,</span>
          <span class="s1">epochs=</span><span class="s3">50</span><span class="s1">,</span>
          <span class="s1">batch_size=batch_size,</span>
          <span class="s1">validation_data=(test_images, test_labels),</span>
          <span class="s1">callbacks=[cp_callback],</span>
          <span class="s1">verbose=</span><span class="s3">0</span><span class="s1">)</span>

<span class="s1">os.listdir(checkpoint_dir)</span>

<span class="s1">latest = tf.train.latest_checkpoint(checkpoint_dir)</span>
<span class="s1">latest</span>

<span class="s0"># Create a new model instance</span>
<span class="s1">model = create_model()</span>

<span class="s0"># Load the previously saved weights</span>
<span class="s1">model.load_weights(latest)</span>

<span class="s0"># Re-evaluate the model</span>
<span class="s1">loss, acc = model.evaluate(test_images, test_labels,</span>
                           <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">&quot;Restored model, accuracy: {:5.2f}%&quot;</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s0">## What are these files?</span>

<span class="s0">## Manually save weights</span>
<span class="s0"># Save the weights</span>
<span class="s1">model.save_weights(</span><span class="s4">'./checkpoints/my_checkpoint'</span><span class="s1">)</span>

<span class="s0"># Create a new model instance</span>
<span class="s1">model = create_model()</span>

<span class="s0"># Restore the weights</span>
<span class="s1">model.load_weights(</span><span class="s4">'./checkpoints/my_checkpoint'</span><span class="s1">)</span>

<span class="s0"># Evaluate the model</span>
<span class="s1">loss, acc = model.evaluate(test_images, test_labels,</span>
                           <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">&quot;Restored model, accuracy: {:5.2f}%&quot;</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s0">## Save the entire model</span>
<span class="s0">### New high-level .keras format</span>
<span class="s0"># Create and train a new model instance.</span>
<span class="s1">model = create_model()</span>
<span class="s1">model.fit(train_images, train_labels,</span>
          <span class="s1">epochs=</span><span class="s3">5</span><span class="s1">)</span>

<span class="s0"># Save the entire model as a `.keras` zip archive.</span>
<span class="s1">model.save(</span><span class="s4">'my_model.keras'</span><span class="s1">)</span>

<span class="s0"># Reload a fresh Keras model from the `.keras` zip archive:</span>
<span class="s1">new_model = tf.keras.models.load_model(</span><span class="s4">'my_model.keras'</span><span class="s1">)</span>

<span class="s0"># Show the model architecture</span>
<span class="s1">new_model.summary()</span>

<span class="s0"># Evaluate the restored model</span>
<span class="s1">loss, acc = new_model.evaluate(test_images, test_labels,</span>
                               <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">'Restored model, accuracy: {:5.2f}%'</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s1">print(new_model.predict(test_images).shape)</span>

<span class="s0">### SavedModel format</span>
<span class="s0"># Create and train a new model instance.</span>
<span class="s1">model = create_model()</span>
<span class="s1">model.fit(train_images, train_labels,</span>
          <span class="s1">epochs=</span><span class="s3">5</span><span class="s1">)</span>

<span class="s0"># Save the entire model as a SavedModel.</span>
<span class="s0"># ! mkdir -p saved_model</span>
<span class="s1">model.save(</span><span class="s4">'saved_model/my_model'</span><span class="s1">)</span>

<span class="s0"># my_model directory</span>
<span class="s0"># ls saved_model</span>

<span class="s0"># Contains an assets folder, saved_model.pb, and variables folder.</span>
<span class="s0"># ls saved_model/my_model</span>

<span class="s0"># Reload a fresh Keras model from the saved model</span>
<span class="s1">new_model = tf.keras.models.load_model(</span><span class="s4">'saved_model/my_model'</span><span class="s1">)</span>

<span class="s0"># Check its architecture</span>
<span class="s1">new_model.summary()</span>

<span class="s0"># Evaluate the restored model</span>
<span class="s1">loss, acc = new_model.evaluate(test_images, test_labels,</span>
                               <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">'Restored model, accuracy: {:5.2f}%'</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>

<span class="s1">print(new_model.predict(test_images).shape)</span>

<span class="s0">### HDF5 format</span>
<span class="s0"># Create and train a new model instance.</span>
<span class="s1">model = create_model()</span>
<span class="s1">model.fit(train_images, train_labels,</span>
          <span class="s1">epochs=</span><span class="s3">5</span><span class="s1">)</span>

<span class="s0"># Save the entire model to a HDF5 file.</span>
<span class="s0"># The `.h5` extension indicates that the model should be saved to HDF5.</span>
<span class="s1">model.save(</span><span class="s4">'my_model.h5'</span><span class="s1">)</span>

<span class="s0"># Recreate the exact same model, incl. its weights, and the optimizer</span>
<span class="s1">new_model = tf.keras.models.load_model(</span><span class="s4">'my_model.h5'</span><span class="s1">)</span>

<span class="s0"># Show the model architecture</span>
<span class="s1">new_model.summary()</span>

<span class="s0"># Check its accuracy</span>
<span class="s1">loss, acc = new_model.evaluate(test_images, test_labels,</span>
                               <span class="s1">verbose=</span><span class="s3">2</span><span class="s1">)</span>
<span class="s1">print(</span><span class="s4">'Restored model, accuracy: {:5.2f}%'</span><span class="s1">.format(</span><span class="s3">100 </span><span class="s1">* acc))</span>



</pre>
</body>
</html>